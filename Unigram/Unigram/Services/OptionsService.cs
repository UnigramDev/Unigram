// --------------------------------------------------------------------------------------------------
// <auto-generatedInfo>
// 	This code was generated by TdParseOptions (http://github.com/UnigramDev/UnigramUtils/TdParseOptions)
// 
// 	Generated: 04/17/2022 14:05:51
// </auto-generatedInfo>
// --------------------------------------------------------------------------------------------------
using System.Collections.Generic;
using Telegram.Td.Api;

namespace Unigram.Services
{
    public interface IOptionsService : IHandle<UpdateOption>
    {
        IReadOnlyDictionary<string, OptionValue> Values { get; }

        T GetValue<T>(string key);
        bool TryGetValue<T>(string key, out T value);

        void Clear();



        /// <summary>
        /// TBD
        /// </summary>
        /// <value>storage_max_time_from_last_access</value>
        long StorageMaxTimeFromLastAccess { get; set; }

        /// <summary>
        /// TBD
        /// </summary>
        /// <value>notification_sound_count_max</value>
        long NotificationSoundCountMax { get; }

        /// <summary>
        /// TBD
        /// </summary>
        /// <value>notification_sound_size_max</value>
        long NotificationSoundSizeMax { get; }

        /// <summary>
        /// TBD
        /// </summary>
        /// <value>notification_sound_duration_max</value>
        long NotificationSoundDurationMax { get; }

        /// <summary>
        /// TBD
        /// </summary>
        /// <value>x_system_proxy_id</value>
        long SystemProxyId { get; set; }

        /// <summary>
        /// If true, text entities will be automatically parsed in all inputMessageText objects
        /// </summary>
        /// <value>always_parse_markdown</value>
        bool AlwaysParseMarkdown { get; set; }

        /// <summary>
        /// If true, new chats from non-contacts will be automatically archived and muted. The option can be set only if the option "can_archive_and_mute_new_chats_from_unknown_users" is true. getOption needs to be called explicitly to fetch the latest value of the option, changed from another device
        /// </summary>
        /// <value>archive_and_mute_new_chats_from_unknown_users</value>
        bool ArchiveAndMuteNewChatsFromUnknownUsers { get; set; }

        /// <summary>
        /// If true, animated emoji will be disabled and shown as plain emoji
        /// </summary>
        /// <value>disable_animated_emoji</value>
        bool DisableAnimatedEmoji { get; set; }

        /// <summary>
        /// If true, notifications about the user's contacts who have joined Telegram will be disabled. User will still receive the corresponding message in the private chat. getOption needs to be called explicitly to fetch the latest value of the option, changed from another device
        /// </summary>
        /// <value>disable_contact_registered_notifications</value>
        bool DisableContactRegisteredNotifications { get; set; }

        /// <summary>
        /// If true, persistent network statistics will be disabled, which significantly reduces disk usage
        /// </summary>
        /// <value>disable_persistent_network_statistics</value>
        bool DisablePersistentNetworkStatistics { get; set; }

        /// <summary>
        /// If true, notifications about outgoing scheduled messages that were sent will be disabled
        /// </summary>
        /// <value>disable_sent_scheduled_message_notifications</value>
        bool DisableSentScheduledMessageNotifications { get; set; }

        /// <summary>
        /// If true, protection from external time adjustment will be disabled, which significantly reduces disk usage
        /// </summary>
        /// <value>disable_time_adjustment_protection</value>
        bool DisableTimeAdjustmentProtection { get; set; }

        /// <summary>
        /// If true, support for top chats and statistics collection is disabled
        /// </summary>
        /// <value>disable_top_chats</value>
        bool DisableTopChats { get; set; }

        /// <summary>
        /// If true, allows to skip all updates received while the TDLib instance was not running. The option does nothing if the database or secret chats are used
        /// </summary>
        /// <value>ignore_background_updates</value>
        bool IgnoreBackgroundUpdates { get; set; }

        /// <summary>
        /// If true, the disable_notification value specified in the request will be always used instead of the default value
        /// </summary>
        /// <value>ignore_default_disable_notification</value>
        bool IgnoreDefaultDisableNotification { get; set; }

        /// <summary>
        /// If true, prevents file thumbnails sent by the server along with messages from being saved on the disk
        /// </summary>
        /// <value>ignore_inline_thumbnails</value>
        bool IgnoreInlineThumbnails { get; set; }

        /// <summary>
        /// If true, chat and message restrictions specific to the currently used operating system will be ignored
        /// </summary>
        /// <value>ignore_platform_restrictions</value>
        bool IgnorePlatformRestrictions { get; set; }

        /// <summary>
        /// If true, sensitive content will be shown on all user devices. getOption needs to be called explicitly to fetch the latest value of the option, changed from another device
        /// </summary>
        /// <value>ignore_sensitive_content_restrictions</value>
        bool IgnoreSensitiveContentRestrictions { get; set; }

        /// <summary>
        /// If true, other users will be allowed to see the current user's location. getOption needs to be called explicitly to fetch the latest value of the option, changed from another device
        /// </summary>
        /// <value>is_location_visible</value>
        bool IsLocationVisible { get; set; }

        /// <summary>
        /// Path to a database for storing language pack strings, so that this database can be shared between different accounts. By default, language pack strings are stored only in memory. Changes of value of this option will be applied only after TDLib restart, so it should be set before call to setTdlibParameters.
        /// </summary>
        /// <value>language_pack_database_path</value>
        string LanguagePackDatabasePath { get; set; }

        /// <summary>
        /// Identifier of the currently used language pack from the current localization target
        /// </summary>
        /// <value>language_pack_id</value>
        string LanguagePackId { get; set; }

        /// <summary>
        /// Name for the current localization target (currently supported: "android", "android_x", "ios", "macos" and "tdesktop")
        /// </summary>
        /// <value>localization_target</value>
        string LocalizationTarget { get; set; }

        /// <summary>
        /// The maximum time messages are stored in memory before they are unloaded, 60-86400; in seconds. Defaults to 60 for users and 1800 for bots
        /// </summary>
        /// <value>message_unload_delay</value>
        long MessageUnloadDelay { get; set; }

        /// <summary>
        /// Maximum number of notification groups to be shown simultaneously, 0-25
        /// </summary>
        /// <value>notification_group_count_max</value>
        long NotificationGroupCountMax { get; set; }

        /// <summary>
        /// Maximum number of simultaneously shown notifications in a group, 1-25. Defaults to 10
        /// </summary>
        /// <value>notification_group_size_max</value>
        long NotificationGroupSizeMax { get; set; }

        /// <summary>
        /// Online status of the current user
        /// </summary>
        /// <value>online</value>
        bool Online { get; set; }

        /// <summary>
        /// If true, IPv6 addresses will be preferred over IPv4 addresses
        /// </summary>
        /// <value>prefer_ipv6</value>
        bool PreferIpv6 { get; set; }

        /// <summary>
        /// If true, Perfect Forward Secrecy will be enabled for interaction with the Telegram servers for cloud chats
        /// </summary>
        /// <value>use_pfs</value>
        bool UsePfs { get; set; }

        /// <summary>
        /// If true, quick acknowledgement will be enabled for outgoing messages
        /// </summary>
        /// <value>use_quick_ack</value>
        bool UseQuickAck { get; set; }

        /// <summary>
        /// If true, the background storage optimizer will be enabled
        /// </summary>
        /// <value>use_storage_optimizer</value>
        bool UseStorageOptimizer { get; set; }

        /// <summary>
        /// A UTC time offset used for splitting messages by days. The option is reset automatically on each TDLib instance launch, so it needs to be set manually only if the time offset is changed during execution.
        /// </summary>
        /// <value>utc_time_offset</value>
        long UtcTimeOffset { get; set; }

        /// <summary>
        /// Username of a bot which can be used in inline mode for animations search
        /// </summary>
        /// <value>animation_search_bot_username</value>
        string AnimationSearchBotUsername { get; }

        /// <summary>
        /// An authentication token to be used on subsequent authorizations and received when logging out
        /// </summary>
        /// <value>authentication_token</value>
        string AuthenticationToken { get; }

        /// <summary>
        /// Point in time (Unix timestamp) when authorization was received
        /// </summary>
        /// <value>authorization_date</value>
        long AuthorizationDate { get; }

        /// <summary>
        /// Maximum number of members in a basic group
        /// </summary>
        /// <value>basic_group_size_max</value>
        long BasicGroupSizeMax { get; }

        /// <summary>
        /// Maximum time to wait for call connection creation to be passed to libtgvoip
        /// </summary>
        /// <value>call_connect_timeout_ms</value>
        long CallConnectTimeoutMs { get; }

        /// <summary>
        /// Maximum time to wait for call packet delivery to be passed to libtgvoip
        /// </summary>
        /// <value>call_packet_timeout_ms</value>
        long CallPacketTimeoutMs { get; }

        /// <summary>
        /// If true, the option "archive_and_mute_new_chats_from_unknown_users" can be changed
        /// </summary>
        /// <value>can_archive_and_mute_new_chats_from_unknown_users</value>
        bool CanArchiveAndMuteNewChatsFromUnknownUsers { get; }

        /// <summary>
        /// If true, the option "ignore_sensitive_content_restrictions" can be changed
        /// </summary>
        /// <value>can_ignore_sensitive_content_restrictions</value>
        bool CanIgnoreSensitiveContentRestrictions { get; }

        /// <summary>
        /// Identifier of the bot which is shown as the sender of messages sent on behalf of channels when viewed from an outdated client
        /// </summary>
        /// <value>channel_bot_user_id</value>
        long ChannelBotUserId { get; }

        /// <summary>
        /// Identifier of the enabled proxy
        /// </summary>
        /// <value>enabled_proxy_id</value>
        long EnabledProxyId { get; }

        /// <summary>
        /// If true, access to Telegram is likely blocked for the user
        /// </summary>
        /// <value>expect_blocking</value>
        bool ExpectBlocking { get; }

        /// <summary>
        /// Maximum number of favorite stickers
        /// </summary>
        /// <value>favorite_stickers_limit</value>
        long FavoriteStickersLimit { get; }

        /// <summary>
        /// Maximum number of forwarded messages per one request
        /// </summary>
        /// <value>forwarded_message_count_max</value>
        long ForwardedMessageCountMax { get; }

        /// <summary>
        /// Identifier of the bot which is shown as the sender of anonymous messages in groups when viewed from an outdated client
        /// </summary>
        /// <value>group_anonymous_bot_user_id</value>
        long GroupAnonymousBotUserId { get; }

        /// <summary>
        /// Maximum length of a message caption
        /// </summary>
        /// <value>message_caption_length_max</value>
        long MessageCaptionLengthMax { get; }

        /// <summary>
        /// Maximum length of a message text
        /// </summary>
        /// <value>message_text_length_max</value>
        long MessageTextLengthMax { get; }

        /// <summary>
        /// Identifier of the current user
        /// </summary>
        /// <value>my_id</value>
        long MyId { get; }

        /// <summary>
        /// Maximum number of pinned cloud chats in the Archive chat list. The same amount of secret chats can be pinned locally
        /// </summary>
        /// <value>pinned_archived_chat_count_max</value>
        long PinnedArchivedChatCountMax { get; }

        /// <summary>
        /// Maximum number of pinned cloud chats in the Main chat list. The same amount of secret chats can be pinned locally
        /// </summary>
        /// <value>pinned_chat_count_max</value>
        long PinnedChatCountMax { get; }

        /// <summary>
        /// Username of a bot which can be used in inline mode for photos search
        /// </summary>
        /// <value>photo_search_bot_username</value>
        string PhotoSearchBotUsername { get; }

        /// <summary>
        /// Identifier of the @replies bot
        /// </summary>
        /// <value>replies_bot_chat_id</value>
        long RepliesBotChatId { get; }

        /// <summary>
        /// Identifier of the language pack, suggested for the user by the server
        /// </summary>
        /// <value>suggested_language_pack_id</value>
        string SuggestedLanguagePackId { get; }

        /// <summary>
        /// Suggested bit rate for audio encoding in video notes, in kbit/s
        /// </summary>
        /// <value>suggested_video_note_audio_bitrate</value>
        long SuggestedVideoNoteAudioBitrate { get; }

        /// <summary>
        /// Suggested width and height of the video in video notes
        /// </summary>
        /// <value>suggested_video_note_length</value>
        long SuggestedVideoNoteLength { get; }

        /// <summary>
        /// Suggested bit rate for video encoding in video notes, in kbit/s
        /// </summary>
        /// <value>suggested_video_note_video_bitrate</value>
        long SuggestedVideoNoteVideoBitrate { get; }

        /// <summary>
        /// Maximum number of members in a supergroup
        /// </summary>
        /// <value>supergroup_size_max</value>
        long SupergroupSizeMax { get; }

        /// <summary>
        /// Current value of t.me URL, i.e. https://t.me/
        /// </summary>
        /// <value>t_me_url</value>
        string TMeUrl { get; }

        /// <summary>
        /// Identifier of the Telegram Service Notifications chat
        /// </summary>
        /// <value>telegram_service_notifications_chat_id</value>
        long TelegramServiceNotificationsChatId { get; }

        /// <summary>
        /// If true, the test environment is being used instead of the production environment
        /// </summary>
        /// <value>test_mode</value>
        bool TestMode { get; }

        /// <summary>
        /// An estimation of the current Unix timestamp. The option will not be updated automatically unless the difference between the previous estimation and the locally available monotonic clocks changes significantly
        /// </summary>
        /// <value>unix_time</value>
        long UnixTime { get; }

        /// <summary>
        /// Username of a bot which can be used in inline mode for venues search
        /// </summary>
        /// <value>venue_search_bot_username</value>
        string VenueSearchBotUsername { get; }

        /// <summary>
        /// TDLib version. This options is guaranteed to come before all other updates since TDLib 1.4.0
        /// </summary>
        /// <value>version</value>
        string Version { get; }
    }

    public class OptionsService : IOptionsService
    {
        private readonly IProtoService _protoService;
        private readonly Dictionary<string, OptionValue> _values = new Dictionary<string, OptionValue>();

        public OptionsService(IProtoService protoService)
        {
            _protoService = protoService;
        }

        public void Handle(UpdateOption update)
        {
            switch (update.Name)
            {
                case "storage_max_time_from_last_access":
                    _storageMaxTimeFromLastAccess = GetValue<long>(update.Value);
                    break;
                case "notification_sound_count_max":
                    _notificationSoundCountMax = GetValue<long>(update.Value);
                    break;
                case "notification_sound_size_max":
                    _notificationSoundSizeMax = GetValue<long>(update.Value);
                    break;
                case "notification_sound_duration_max":
                    _notificationSoundDurationMax = GetValue<long>(update.Value);
                    break;
                case "x_system_proxy_id":
                    _systemProxyId = GetValue<long>(update.Value);
                    break;
                case "always_parse_markdown":
                    _alwaysParseMarkdown = GetValue<bool>(update.Value);
                    break;
                case "archive_and_mute_new_chats_from_unknown_users":
                    _archiveAndMuteNewChatsFromUnknownUsers = GetValue<bool>(update.Value);
                    break;
                case "disable_animated_emoji":
                    _disableAnimatedEmoji = GetValue<bool>(update.Value);
                    break;
                case "disable_contact_registered_notifications":
                    _disableContactRegisteredNotifications = GetValue<bool>(update.Value);
                    break;
                case "disable_persistent_network_statistics":
                    _disablePersistentNetworkStatistics = GetValue<bool>(update.Value);
                    break;
                case "disable_sent_scheduled_message_notifications":
                    _disableSentScheduledMessageNotifications = GetValue<bool>(update.Value);
                    break;
                case "disable_time_adjustment_protection":
                    _disableTimeAdjustmentProtection = GetValue<bool>(update.Value);
                    break;
                case "disable_top_chats":
                    _disableTopChats = GetValue<bool>(update.Value);
                    break;
                case "ignore_background_updates":
                    _ignoreBackgroundUpdates = GetValue<bool>(update.Value);
                    break;
                case "ignore_default_disable_notification":
                    _ignoreDefaultDisableNotification = GetValue<bool>(update.Value);
                    break;
                case "ignore_inline_thumbnails":
                    _ignoreInlineThumbnails = GetValue<bool>(update.Value);
                    break;
                case "ignore_platform_restrictions":
                    _ignorePlatformRestrictions = GetValue<bool>(update.Value);
                    break;
                case "ignore_sensitive_content_restrictions":
                    _ignoreSensitiveContentRestrictions = GetValue<bool>(update.Value);
                    break;
                case "is_location_visible":
                    _isLocationVisible = GetValue<bool>(update.Value);
                    break;
                case "language_pack_database_path":
                    _languagePackDatabasePath = GetValue<string>(update.Value);
                    break;
                case "language_pack_id":
                    _languagePackId = GetValue<string>(update.Value);
                    break;
                case "localization_target":
                    _localizationTarget = GetValue<string>(update.Value);
                    break;
                case "message_unload_delay":
                    _messageUnloadDelay = GetValue<long>(update.Value);
                    break;
                case "notification_group_count_max":
                    _notificationGroupCountMax = GetValue<long>(update.Value);
                    break;
                case "notification_group_size_max":
                    _notificationGroupSizeMax = GetValue<long>(update.Value);
                    break;
                case "online":
                    _online = GetValue<bool>(update.Value);
                    break;
                case "prefer_ipv6":
                    _preferIpv6 = GetValue<bool>(update.Value);
                    break;
                case "use_pfs":
                    _usePfs = GetValue<bool>(update.Value);
                    break;
                case "use_quick_ack":
                    _useQuickAck = GetValue<bool>(update.Value);
                    break;
                case "use_storage_optimizer":
                    _useStorageOptimizer = GetValue<bool>(update.Value);
                    break;
                case "utc_time_offset":
                    _utcTimeOffset = GetValue<long>(update.Value);
                    break;
                case "animation_search_bot_username":
                    _animationSearchBotUsername = GetValue<string>(update.Value);
                    break;
                case "authentication_token":
                    _authenticationToken = GetValue<string>(update.Value);
                    break;
                case "authorization_date":
                    _authorizationDate = GetValue<long>(update.Value);
                    break;
                case "basic_group_size_max":
                    _basicGroupSizeMax = GetValue<long>(update.Value);
                    break;
                case "call_connect_timeout_ms":
                    _callConnectTimeoutMs = GetValue<long>(update.Value);
                    break;
                case "call_packet_timeout_ms":
                    _callPacketTimeoutMs = GetValue<long>(update.Value);
                    break;
                case "can_archive_and_mute_new_chats_from_unknown_users":
                    _canArchiveAndMuteNewChatsFromUnknownUsers = GetValue<bool>(update.Value);
                    break;
                case "can_ignore_sensitive_content_restrictions":
                    _canIgnoreSensitiveContentRestrictions = GetValue<bool>(update.Value);
                    break;
                case "channel_bot_user_id":
                    _channelBotUserId = GetValue<long>(update.Value);
                    break;
                case "enabled_proxy_id":
                    _enabledProxyId = GetValue<long>(update.Value);
                    break;
                case "expect_blocking":
                    _expectBlocking = GetValue<bool>(update.Value);
                    break;
                case "favorite_stickers_limit":
                    _favoriteStickersLimit = GetValue<long>(update.Value);
                    break;
                case "forwarded_message_count_max":
                    _forwardedMessageCountMax = GetValue<long>(update.Value);
                    break;
                case "group_anonymous_bot_user_id":
                    _groupAnonymousBotUserId = GetValue<long>(update.Value);
                    break;
                case "message_caption_length_max":
                    _messageCaptionLengthMax = GetValue<long>(update.Value);
                    break;
                case "message_text_length_max":
                    _messageTextLengthMax = GetValue<long>(update.Value);
                    break;
                case "my_id":
                    _myId = GetValue<long>(update.Value);
                    break;
                case "pinned_archived_chat_count_max":
                    _pinnedArchivedChatCountMax = GetValue<long>(update.Value);
                    break;
                case "pinned_chat_count_max":
                    _pinnedChatCountMax = GetValue<long>(update.Value);
                    break;
                case "photo_search_bot_username":
                    _photoSearchBotUsername = GetValue<string>(update.Value);
                    break;
                case "replies_bot_chat_id":
                    _repliesBotChatId = GetValue<long>(update.Value);
                    break;
                case "suggested_language_pack_id":
                    _suggestedLanguagePackId = GetValue<string>(update.Value);
                    break;
                case "suggested_video_note_audio_bitrate":
                    _suggestedVideoNoteAudioBitrate = GetValue<long>(update.Value);
                    break;
                case "suggested_video_note_length":
                    _suggestedVideoNoteLength = GetValue<long>(update.Value);
                    break;
                case "suggested_video_note_video_bitrate":
                    _suggestedVideoNoteVideoBitrate = GetValue<long>(update.Value);
                    break;
                case "supergroup_size_max":
                    _supergroupSizeMax = GetValue<long>(update.Value);
                    break;
                case "t_me_url":
                    _tMeUrl = GetValue<string>(update.Value);
                    break;
                case "telegram_service_notifications_chat_id":
                    _telegramServiceNotificationsChatId = GetValue<long>(update.Value);
                    break;
                case "test_mode":
                    _testMode = GetValue<bool>(update.Value);
                    break;
                case "unix_time":
                    _unixTime = GetValue<long>(update.Value);
                    break;
                case "venue_search_bot_username":
                    _venueSearchBotUsername = GetValue<string>(update.Value);
                    break;
                case "version":
                    _version = GetValue<string>(update.Value);
                    break;
                default:
                    _values[update.Name] = update.Value;
                    break;
            }
        }

        private T GetValue<T>(OptionValue option)
        {
            if (option is OptionValueBoolean valueBoolean && typeof(T) == typeof(bool))
            {
                return (T)(object)valueBoolean.Value;
            }
            else if (option is OptionValueInteger valueInteger && typeof(T) == typeof(long))
            {
                return (T)(object)valueInteger.Value;
            }
            else if (option is OptionValueString valueString && typeof(T) == typeof(string))
            {
                return (T)(object)valueString.Value;
            }
            else if (option is OptionValueEmpty)
            {
                return default(T);
            }

            return default(T);
        }

        private bool TryGetValue<T>(OptionValue option, out T value)
        {
            if (option is OptionValueBoolean valueBoolean && typeof(T) == typeof(bool))
            {
                value = (T)(object)valueBoolean.Value;
                return true;
            }
            else if (option is OptionValueInteger valueInteger && typeof(T) == typeof(long))
            {
                value = (T)(object)valueInteger.Value;
                return true;
            }
            else if (option is OptionValueString valueString && typeof(T) == typeof(string))
            {
                value = (T)(object)valueString.Value;
                return true;
            }
            else if (option is OptionValueEmpty)
            {
                value = default(T);
                return false;
            }

            value = default(T);
            return false;
        }



        public IReadOnlyDictionary<string, OptionValue> Values => _values;

        public T GetValue<T>(string key)
        {
            if (_values.TryGetValue(key, out OptionValue option))
            {
                return GetValue<T>(option);
            }

            return default(T);
        }

        public bool TryGetValue<T>(string key, out T value)
        {
            if (_values.TryGetValue(key, out OptionValue option))
            {
                return TryGetValue<T>(option, out value);
            }

            value = default(T);
            return false;
        }

        public void Clear()
        {
            _values.Clear();
        }

        private long _storageMaxTimeFromLastAccess;
        public long StorageMaxTimeFromLastAccess
        {
            get { return _storageMaxTimeFromLastAccess; }
            set
            {
                _storageMaxTimeFromLastAccess = value;
                _protoService.Send(new SetOption("storage_max_time_from_last_access", new OptionValueInteger(value)));
            }
        }

        private long _notificationSoundCountMax;
        public long NotificationSoundCountMax
        {
            get { return _notificationSoundCountMax; }
        }

        private long _notificationSoundSizeMax;
        public long NotificationSoundSizeMax
        {
            get { return _notificationSoundSizeMax; }
        }

        private long _notificationSoundDurationMax;
        public long NotificationSoundDurationMax
        {
            get { return _notificationSoundDurationMax; }
        }

        private long _systemProxyId;
        public long SystemProxyId
        {
            get { return _systemProxyId; }
            set
            {
                _systemProxyId = value;
                _protoService.Send(new SetOption("x_system_proxy_id", new OptionValueInteger(value)));
            }
        }

        private bool _alwaysParseMarkdown;
        public bool AlwaysParseMarkdown
        {
            get { return _alwaysParseMarkdown; }
            set
            {
                _alwaysParseMarkdown = value;
                _protoService.Send(new SetOption("always_parse_markdown", new OptionValueBoolean(value)));
            }
        }

        private bool _archiveAndMuteNewChatsFromUnknownUsers;
        public bool ArchiveAndMuteNewChatsFromUnknownUsers
        {
            get { return _archiveAndMuteNewChatsFromUnknownUsers; }
            set
            {
                _archiveAndMuteNewChatsFromUnknownUsers = value;
                _protoService.Send(new SetOption("archive_and_mute_new_chats_from_unknown_users", new OptionValueBoolean(value)));
            }
        }

        private bool _disableAnimatedEmoji;
        public bool DisableAnimatedEmoji
        {
            get { return _disableAnimatedEmoji; }
            set
            {
                _disableAnimatedEmoji = value;
                _protoService.Send(new SetOption("disable_animated_emoji", new OptionValueBoolean(value)));
            }
        }

        private bool _disableContactRegisteredNotifications;
        public bool DisableContactRegisteredNotifications
        {
            get { return _disableContactRegisteredNotifications; }
            set
            {
                _disableContactRegisteredNotifications = value;
                _protoService.Send(new SetOption("disable_contact_registered_notifications", new OptionValueBoolean(value)));
            }
        }

        private bool _disablePersistentNetworkStatistics;
        public bool DisablePersistentNetworkStatistics
        {
            get { return _disablePersistentNetworkStatistics; }
            set
            {
                _disablePersistentNetworkStatistics = value;
                _protoService.Send(new SetOption("disable_persistent_network_statistics", new OptionValueBoolean(value)));
            }
        }

        private bool _disableSentScheduledMessageNotifications;
        public bool DisableSentScheduledMessageNotifications
        {
            get { return _disableSentScheduledMessageNotifications; }
            set
            {
                _disableSentScheduledMessageNotifications = value;
                _protoService.Send(new SetOption("disable_sent_scheduled_message_notifications", new OptionValueBoolean(value)));
            }
        }

        private bool _disableTimeAdjustmentProtection;
        public bool DisableTimeAdjustmentProtection
        {
            get { return _disableTimeAdjustmentProtection; }
            set
            {
                _disableTimeAdjustmentProtection = value;
                _protoService.Send(new SetOption("disable_time_adjustment_protection", new OptionValueBoolean(value)));
            }
        }

        private bool _disableTopChats;
        public bool DisableTopChats
        {
            get { return _disableTopChats; }
            set
            {
                _disableTopChats = value;
                _protoService.Send(new SetOption("disable_top_chats", new OptionValueBoolean(value)));
            }
        }

        private bool _ignoreBackgroundUpdates;
        public bool IgnoreBackgroundUpdates
        {
            get { return _ignoreBackgroundUpdates; }
            set
            {
                _ignoreBackgroundUpdates = value;
                _protoService.Send(new SetOption("ignore_background_updates", new OptionValueBoolean(value)));
            }
        }

        private bool _ignoreDefaultDisableNotification;
        public bool IgnoreDefaultDisableNotification
        {
            get { return _ignoreDefaultDisableNotification; }
            set
            {
                _ignoreDefaultDisableNotification = value;
                _protoService.Send(new SetOption("ignore_default_disable_notification", new OptionValueBoolean(value)));
            }
        }

        private bool _ignoreInlineThumbnails;
        public bool IgnoreInlineThumbnails
        {
            get { return _ignoreInlineThumbnails; }
            set
            {
                _ignoreInlineThumbnails = value;
                _protoService.Send(new SetOption("ignore_inline_thumbnails", new OptionValueBoolean(value)));
            }
        }

        private bool _ignorePlatformRestrictions;
        public bool IgnorePlatformRestrictions
        {
            get { return _ignorePlatformRestrictions; }
            set
            {
                _ignorePlatformRestrictions = value;
                _protoService.Send(new SetOption("ignore_platform_restrictions", new OptionValueBoolean(value)));
            }
        }

        private bool _ignoreSensitiveContentRestrictions;
        public bool IgnoreSensitiveContentRestrictions
        {
            get { return _ignoreSensitiveContentRestrictions; }
            set
            {
                _ignoreSensitiveContentRestrictions = value;
                _protoService.Send(new SetOption("ignore_sensitive_content_restrictions", new OptionValueBoolean(value)));
            }
        }

        private bool _isLocationVisible;
        public bool IsLocationVisible
        {
            get { return _isLocationVisible; }
            set
            {
                _isLocationVisible = value;
                _protoService.Send(new SetOption("is_location_visible", new OptionValueBoolean(value)));
            }
        }

        private string _languagePackDatabasePath;
        public string LanguagePackDatabasePath
        {
            get { return _languagePackDatabasePath; }
            set
            {
                _languagePackDatabasePath = value;
                if (value == null)
                {
                    _protoService.Send(new SetOption("language_pack_database_path", new OptionValueEmpty()));
                }
                else
                {
                    _protoService.Send(new SetOption("language_pack_database_path", new OptionValueString(value)));
                }
            }
        }

        private string _languagePackId;
        public string LanguagePackId
        {
            get { return _languagePackId; }
            set
            {
                _languagePackId = value;
                if (value == null)
                {
                    _protoService.Send(new SetOption("language_pack_id", new OptionValueEmpty()));
                }
                else
                {
                    _protoService.Send(new SetOption("language_pack_id", new OptionValueString(value)));
                }
            }
        }

        private string _localizationTarget;
        public string LocalizationTarget
        {
            get { return _localizationTarget; }
            set
            {
                _localizationTarget = value;
                if (value == null)
                {
                    _protoService.Send(new SetOption("localization_target", new OptionValueEmpty()));
                }
                else
                {
                    _protoService.Send(new SetOption("localization_target", new OptionValueString(value)));
                }
            }
        }

        private long _messageUnloadDelay;
        public long MessageUnloadDelay
        {
            get { return _messageUnloadDelay; }
            set
            {
                _messageUnloadDelay = value;
                _protoService.Send(new SetOption("message_unload_delay", new OptionValueInteger(value)));
            }
        }

        private long _notificationGroupCountMax;
        public long NotificationGroupCountMax
        {
            get { return _notificationGroupCountMax; }
            set
            {
                _notificationGroupCountMax = value;
                _protoService.Send(new SetOption("notification_group_count_max", new OptionValueInteger(value)));
            }
        }

        private long _notificationGroupSizeMax;
        public long NotificationGroupSizeMax
        {
            get { return _notificationGroupSizeMax; }
            set
            {
                _notificationGroupSizeMax = value;
                _protoService.Send(new SetOption("notification_group_size_max", new OptionValueInteger(value)));
            }
        }

        private bool _online;
        public bool Online
        {
            get { return _online; }
            set
            {
                _online = value;
                _protoService.Send(new SetOption("online", new OptionValueBoolean(value)));
            }
        }

        private bool _preferIpv6;
        public bool PreferIpv6
        {
            get { return _preferIpv6; }
            set
            {
                _preferIpv6 = value;
                _protoService.Send(new SetOption("prefer_ipv6", new OptionValueBoolean(value)));
            }
        }

        private bool _usePfs;
        public bool UsePfs
        {
            get { return _usePfs; }
            set
            {
                _usePfs = value;
                _protoService.Send(new SetOption("use_pfs", new OptionValueBoolean(value)));
            }
        }

        private bool _useQuickAck;
        public bool UseQuickAck
        {
            get { return _useQuickAck; }
            set
            {
                _useQuickAck = value;
                _protoService.Send(new SetOption("use_quick_ack", new OptionValueBoolean(value)));
            }
        }

        private bool _useStorageOptimizer;
        public bool UseStorageOptimizer
        {
            get { return _useStorageOptimizer; }
            set
            {
                _useStorageOptimizer = value;
                _protoService.Send(new SetOption("use_storage_optimizer", new OptionValueBoolean(value)));
            }
        }

        private long _utcTimeOffset;
        public long UtcTimeOffset
        {
            get { return _utcTimeOffset; }
            set
            {
                _utcTimeOffset = value;
                _protoService.Send(new SetOption("utc_time_offset", new OptionValueInteger(value)));
            }
        }

        private string _animationSearchBotUsername;
        public string AnimationSearchBotUsername
        {
            get { return _animationSearchBotUsername; }
        }

        private string _authenticationToken;
        public string AuthenticationToken
        {
            get { return _authenticationToken; }
        }

        private long _authorizationDate;
        public long AuthorizationDate
        {
            get { return _authorizationDate; }
        }

        private long _basicGroupSizeMax;
        public long BasicGroupSizeMax
        {
            get { return _basicGroupSizeMax; }
        }

        private long _callConnectTimeoutMs;
        public long CallConnectTimeoutMs
        {
            get { return _callConnectTimeoutMs; }
        }

        private long _callPacketTimeoutMs;
        public long CallPacketTimeoutMs
        {
            get { return _callPacketTimeoutMs; }
        }

        private bool _canArchiveAndMuteNewChatsFromUnknownUsers;
        public bool CanArchiveAndMuteNewChatsFromUnknownUsers
        {
            get { return _canArchiveAndMuteNewChatsFromUnknownUsers; }
        }

        private bool _canIgnoreSensitiveContentRestrictions;
        public bool CanIgnoreSensitiveContentRestrictions
        {
            get { return _canIgnoreSensitiveContentRestrictions; }
        }

        private long _channelBotUserId;
        public long ChannelBotUserId
        {
            get { return _channelBotUserId; }
        }

        private long _enabledProxyId;
        public long EnabledProxyId
        {
            get { return _enabledProxyId; }
        }

        private bool _expectBlocking;
        public bool ExpectBlocking
        {
            get { return _expectBlocking; }
        }

        private long _favoriteStickersLimit;
        public long FavoriteStickersLimit
        {
            get { return _favoriteStickersLimit; }
        }

        private long _forwardedMessageCountMax;
        public long ForwardedMessageCountMax
        {
            get { return _forwardedMessageCountMax; }
        }

        private long _groupAnonymousBotUserId;
        public long GroupAnonymousBotUserId
        {
            get { return _groupAnonymousBotUserId; }
        }

        private long _messageCaptionLengthMax;
        public long MessageCaptionLengthMax
        {
            get { return _messageCaptionLengthMax; }
        }

        private long _messageTextLengthMax;
        public long MessageTextLengthMax
        {
            get { return _messageTextLengthMax; }
        }

        private long _myId;
        public long MyId
        {
            get { return _myId; }
        }

        private long _pinnedArchivedChatCountMax;
        public long PinnedArchivedChatCountMax
        {
            get { return _pinnedArchivedChatCountMax; }
        }

        private long _pinnedChatCountMax;
        public long PinnedChatCountMax
        {
            get { return _pinnedChatCountMax; }
        }

        private string _photoSearchBotUsername;
        public string PhotoSearchBotUsername
        {
            get { return _photoSearchBotUsername; }
        }

        private long _repliesBotChatId;
        public long RepliesBotChatId
        {
            get { return _repliesBotChatId; }
        }

        private string _suggestedLanguagePackId;
        public string SuggestedLanguagePackId
        {
            get { return _suggestedLanguagePackId; }
        }

        private long _suggestedVideoNoteAudioBitrate;
        public long SuggestedVideoNoteAudioBitrate
        {
            get { return _suggestedVideoNoteAudioBitrate; }
        }

        private long _suggestedVideoNoteLength;
        public long SuggestedVideoNoteLength
        {
            get { return _suggestedVideoNoteLength; }
        }

        private long _suggestedVideoNoteVideoBitrate;
        public long SuggestedVideoNoteVideoBitrate
        {
            get { return _suggestedVideoNoteVideoBitrate; }
        }

        private long _supergroupSizeMax;
        public long SupergroupSizeMax
        {
            get { return _supergroupSizeMax; }
        }

        private string _tMeUrl;
        public string TMeUrl
        {
            get { return _tMeUrl; }
        }

        private long _telegramServiceNotificationsChatId;
        public long TelegramServiceNotificationsChatId
        {
            get { return _telegramServiceNotificationsChatId; }
        }

        private bool _testMode;
        public bool TestMode
        {
            get { return _testMode; }
        }

        private long _unixTime;
        public long UnixTime
        {
            get { return _unixTime; }
        }

        private string _venueSearchBotUsername;
        public string VenueSearchBotUsername
        {
            get { return _venueSearchBotUsername; }
        }

        private string _version;
        public string Version
        {
            get { return _version; }
        }
    }
}
